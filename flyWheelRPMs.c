#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           flyWheel1,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           flyWheel2,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           flyWheel3,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           flyWheel4,     tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "PIDController.h"

PID flyWheel;

void pre_auton()
{
}

task autonomous()
{
}

void driveFlywheel(int output)
{
	motor[flyWheel1] =
	motor[flyWheel2] =
	motor[flyWheel3] =
	motor[flyWheel4] = -output;
}

float rpmAvg = 0;
float dT; //delta T in seconds
float battery;
float average = 0;
int index = 0;
float out;
float kp, ki, kd, error;
float sp = 3400;

task usercontrol()
{
	pidInit(flyWheel, 0.02, 0.0, 0.01, 100, 63);
	unsigned long lastTime = nPgmTime;
	resetMotorEncoder(flyWheel4);
	bool runFlyWheel = false;
	bool btn8UPressed = false;
	unsigned short counter = 0;
	bool collect = false;
	float avg;
	float rpm, lastRpm1, lastRpm2, lastRpm3, lastRpm4;

	while (true)
	{
		kp = flyWheel.kP;
		ki = flyWheel.kI;
		kd = flyWheel.kD;
		error = flyWheel.error;

		dT = (float)(nPgmTime - lastTime)/1000;
		lastTime = nPgmTime;

		battery = (float)nAvgBatteryLevel / 1000;

		if(vexRT(Btn8U) && !btn8UPressed)
		{
			btn8UPressed = true;
			runFlyWheel = !runFlyWheel;
			if(runFlyWheel)
				pidInit(flyWheel, 0.02, 0.0, 0.01, 100, 63);
		}else if(!vexRT(Btn8U) && btn8UPressed)
			btn8UPressed = false;

		if(dT != 0)
			rpm = 60.00*23.52*(((float)getMotorEncoder(flyWheel4))/dT)/261.333;
		else
			rpm = 0;
		resetMotorEncoder(flyWheel4);

		lastRpm4 = lastRpm3;
		lastRpm3 = lastRpm2;
		lastRpm2 = lastRpm1;
		lastRpm1 = rpm;

		rpmAvg = (rpm + lastRpm1 + lastRpm2 + lastRpm3 + lastRpm4)/5;

		if(rpmAvg >= sp-100 && rpm <= sp+100)
			counter++;
		if(counter >= 3)
			motor[port5] = vexRT(Btn5D)*127 - vexRT(Btn5U)*127;
		if(rpmAvg < sp-200 || rpm > sp+200){
			counter = 0;
			motor[port5] = 0;
		}
		motor[port6] = vexRT(Btn6U)*127 - vexRT(Btn6D)*127;

		if(runFlyWheel)
		{
			sp = 3400;
		}
		else
		{
			sp = 1000;
		}
		out = pidExecute(flyWheel, sp - rpmAvg);
		if(out < 20)
			out = 20;
		driveFlywheel(out);

		if(vexRT(Btn7U))
		{
			index = 0;
			avg = 0;
			collect = true;
		}

		if(collect)
		{
			avg += rpmAvg;
			index++;
		}

		if(index >= 999)
		{
			collect = false;
			average = avg/1000;
		}

		delay(20);
	}
}
