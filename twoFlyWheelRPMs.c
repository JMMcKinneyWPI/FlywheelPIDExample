#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl12, LED,            sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           flyWheelL1,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           flyWheelL2,    tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port8,           flyWheelR1,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           flyWheelR2,    tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "PIDController.h"

PID flyWheelL, flyWheelR;

void pre_auton()
{
}

task autonomous()
{
}

void driveFlywheelLeft(int output)
{
	motor[flyWheelL1] =
	motor[flyWheelL2] = output;
}

void driveFlywheelRight(int output)
{
	motor[flyWheelR1] =
	motor[flyWheelR2] = output;
}

float rpmAvgL = 0;
float rpmAvgR = 0;
float dT; //delta T in seconds
float outL, outR;
float sp = 500;
bool set = false;

task usercontrol()
{
	pidInit(flyWheelL, 0.0, 0.004, 0.00, 0, 50);
	pidInit(flyWheelR, 0.0, 0.004, 0.00, 0, 50);
	unsigned long lastTime = nPgmTime;
	resetMotorEncoder(flyWheelL2);
	resetMotorEncoder(flyWheelR2);
	bool runFlyWheel = false;
	bool btn8UPressed = false;
	float rpmL, lastRpmL1, lastRpmL2, lastRpmL3, lastRpmL4;
	float rpmR, lastRpmR1, lastRpmR2, lastRpmR3, lastRpmR4;
	int counter = 0;

	while (true)
	{
		dT = (float)(nPgmTime - lastTime)/1000;
		lastTime = nPgmTime;

		if(vexRT(Btn8U) && !btn8UPressed)
		{
			btn8UPressed = true;
			runFlyWheel = !runFlyWheel;
		}else if(!vexRT(Btn8U) && btn8UPressed)
			btn8UPressed = false;

		if(dT != 0){
			rpmL = 60.00*23.52*(((float)getMotorEncoder(flyWheelL2))/dT)/261.333;
			rpmR = 60.00*23.52*(((float)getMotorEncoder(flyWheelR2))/dT)/261.333;
		}
		else{
			rpmL = 0;
			rpmR = 0;
		}
		resetMotorEncoder(flyWheelL2);
		resetMotorEncoder(flyWheelR2);

		lastRpmL4 = lastRpmL3;
		lastRpmL3 = lastRpmL2;
		lastRpmL2 = lastRpmL1;
		lastRpmL1 = rpmL;

		lastRpmR4 = lastRpmR3;
		lastRpmR3 = lastRpmR2;
		lastRpmR2 = lastRpmR1;
		lastRpmR1 = rpmR;

		rpmAvgL = (rpmL + lastRpmL1 + lastRpmL2 + lastRpmL3 + lastRpmL4)/5;
		rpmAvgR = (rpmR + lastRpmR1 + lastRpmR2 + lastRpmR3 + lastRpmR4)/5;

		if(rpmAvgR >= sp-150 && rpmR <= sp+150 && rpmAvgL >= sp-150 && rpmL <= sp+150)
			counter++;
		if(counter >= 3)
			SensorValue(LED) = 0;
		if(rpmAvgR < sp-300 || rpmR > sp+300 || rpmAvgL < sp-300 || rpmL > sp+300){
			counter = 0;
			SensorValue(LED) = 1;
		}
		motor[port6] = vexRT(Btn6U)*127 - vexRT(Btn6D)*127;

		if(runFlyWheel)
		{
			sp = 4000;
		}
		else
		{
			sp = 4600;
		}

		if(flyWheelL.errorSum > 20500)
			flyWheelL.errorSum = 20500;

		if(flyWheelR.errorSum > 20500)
			flyWheelR.errorSum = 20500;

		if(rpmAvgR >= sp && rpmAvgL >= sp && !set)
		{
			//flyWheelL.errorSum = 0;
			//flyWheelR.errorSum = 0;
			set = true;
		}

		if(rpmAvgR <= sp-700 && rpmAvgL <= sp-700)
			set = false;

		outL = pidExecute(flyWheelL, sp - rpmAvgL);
		outR = pidExecute(flyWheelR, sp - rpmAvgR);

		if(outL < 1)
			outL = 1;
		driveFlywheelLeft(outL);

		if(outR < 1)
			outR = 1;
		driveFlywheelRight(outR);
	}
}
